---
title: 前端面试题准备 - 网络
date: 2025-02-09 22:20:17
tags:
  - Interview
  - Frontend
  - Network
categories:
  - Interview
top_img: /img/interview.jpg
cover: /img/interview.jpg
---

## OSI 七层与 TCP/IP 五层模型

**OSI 七层模型：**

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层

**TCP/IP 五层模型：**

- 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
- 传输层：TCP，UDP
- 网络层：IP，ICMP，RIP，OSPF，BGP，IGMP
- 数据链路层：SLIP，CSLIP，PPP，ARP，RARP，MTU
- 物理层

---

## 应用层的协议哪些是基于 TCP 协议的，哪些是基于 UDP 协议的？

**基于 TCP 协议的协议：**

- **FTP（文件传输协议）**：定义了文件传输协议，使用 `21` 端口。
- **TELNET（远程登陆协议）**：一种用于远程登陆的端口，使用 `23` 端口，用户可以以自己的身份远程连接到计算机上，可提供基于 DOS 模式下的通信服务。
- **SMTP（简单邮件传输协议）**：邮件传送协议，用于发送邮件。服务器开放的是 `25` 号端口。
- **POP3（邮件读取协议）**：它是和 `SMTP` 对应，`POP3` 用于接收邮件。`POP3` 协议所用的是 `110` 端口。
- **HTTP（超文本传输协议）**：是从 Web 服务器传输超文本到本地浏览器的传送协议。
- **HTTPS（超文本传输安全协议）**：是以安全为目标的 `HTTP` 通道，简单讲是 `HTTP` 的安全版。即 `HTTP` 下加入 `SSL` 层，`HTTPS` 的安全基础是 `SSL`，因此加密的详细内容就需要 `SSL`。

**基于 UDP 协议的协议：**

- **TFTP（简单文件传输协议）**：该协议在熟知端口 `69` 上使用 `UDP` 服务。
- **DHCP（动态主机配置协议）**：是一种局域网的网络协议。主要有两个用途：给内部网络或网络服务供应商自动分配 `IP` 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。
- **RIP（路由信息协议）**：基于距离矢量算法的路由协议，利用跳数来作为计量标准。
- **SNMP（简单网络管理协议）**：使用 `UDP` 的 `161` 端口。用于管理网络设备。
- **BOOTP（引导程序协议）**：是 `TCP/IP` 协议族中的一个，用于网络引导，应用于无盘设备。
- **IGMP（Internet 组管理协议）**：是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。

**基于 TCP 和 UDP 协议的协议：**

- **DNS（域名系统）**：大多数 DNS 查询使用 `UDP` 进行，但当查询超过 `512` 字节时，会使用 `TCP` 进行区域传输。使用 `53` 端口。
- **ECHO（回声协议）**：使用 `TCP` 能可靠地传输数据，使用 `UDP` 能快速地传输数据。使用 `7` 端口。

---

## TCP 和 UDP 的区别

TCP（传输控制协议）和 UDP（用户数据报协议）都是 **传输层协议**。

**TCP** 是 **面向连接、可靠** 的传输协议，适用于需要数据完整性和顺序的场景，比如网页浏览、文件传输等。

- **面向连接**：在通信前需要建立三次握手，确保连接可靠。
- **可靠传输**：数据丢失时，`TCP` 自动重传，保证数据完整性。
- **有序传输**：接收端会按照顺序重组数据，确保数据包不乱序。
- **流量控制**：通过滑动窗口调整发送速率，防止网络拥塞。
- **拥塞控制**：`TCP` 使用算法（如慢启动、拥塞避免）来防止网络过载。

**UDP** 是 **无连接、不可靠** 的协议，适用于对速度要求高、但对数据完整性要求不高的场景，比如视频通话、实时游戏等。

- **无连接**：发送数据前不需要建立连接，发送数据后不需要释放连接。
- **不可靠传输**：不保证数据包的顺序，不保证数据包的完整性，不保证数据包的到达。
- **轻量级**：`UDP` 头部信息较少，开销较小（`UDP` 头部只有 8 个字节，而 `TCP` 头部至少 20 个字节）。
- **快速传输**：没有握手和重传机制，适合低延迟通信。

**TCP 和 UDP 的区别**

- `TCP` 是面向连接的，`UDP` 是无连接的。
- `TCP` 是可靠的，`UDP` 是不可靠的。
- `TCP` 是面向字节流的，`UDP` 是面向报文的。
- `TCP` 只能是一对一，`UDP` 可以是一对一、一对多、多对多。
- `TCP` 首部较大，`UDP` 首部较小。
- `TCP` 有拥塞控制和流量控制，`UDP` 没有。

---

## HTTP 状态码

HTTP 状态码由三位数字组成，第一个数字定义了状态码的类型，后两位数字没有分类作用。

- `1xx`：信息性状态码，表示请求正在处理。
  - `100`：继续
  - `101`：切换协议
- `2xx`：成功状态码，表示请求成功。
  - `200`：请求成功
  - `201`：请求成功并且创建了新的资源
  - `202`：请求已接受，但尚未处理
  - `204`：请求成功，但没有任何内容返回
  - `206`：请求成功，但只有部分内容返回
- `3xx`：重定向状态码，表示需要进一步操作。
  - `301`：永久重定向，表示请求的资源已经被分配了新的 URL，比如启用了新域名、服务器切换到了新机房、网站目录层次重构，这些都算是“永久性”的改变。响应的 Location 首部中应该包含 资源现在所处的 URL
  - `302`：临时重定向，表示请求的资源的 URL 已临时定位到其他位置，客户端应该使用 Location 首部给出的 URL 来临时定位资源。将来的请求仍应使用老的 URL
  - `304`：资源未修改，表示客户端可以继续使用本地缓存
- `4xx`：客户端错误状态码，表示请求错误。
  - `400`：请求错误
  - `401`：未授权，表示客户端没有权限访问该资源，比如没有登录
  - `403`：禁止访问，表示客户端虽然携带了认证信息，但是没有权限访问该资源
  - `404`：未找到资源
  - `405`：方法不允许
  - `429`：请求次数过多
- `5xx`：服务器错误状态码，表示服务器错误。
  - `500`：服务器内部错误
  - `501`：未实现
  - `502`：网关或代理服务器收到无效响应
  - `503`：服务不可用
  - `504`：网关超时

---

## HTTP1.0 和 HTTP1.1 和 HTTP2.0 的区别

**HTTP1.0 和 HTTP1.1 的区别**

1. **缓存处理**：

- `1.0` 的 header 中主要是通过 `If-Modified-Since`（比较资源的最后的更新时间是否一致），`expires`(资源的过期时间，取决于客户端本地时间)
- `1.1` 引入了其他的 `If-Match(比较 ETag 是否一致)`, `If-None-Match(比较 ETag 是否不一致)`, `If-Unmodified-Since(比较资源最后的更新时间是否不一致)`, `Entity tag(资源的匹配信息)`

2. **带宽优化**：

- `1.0` 存在一些浪费带宽的现象，例如客户端只需要某个对象的一部分，但是服务器将整个对象返回。
- `1.1` 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 `206（Partial Content）`

3. Host 头处理：

- `1.0` 中认为每个服务器都有一个唯一的 `IP` 地址，因此请求的 `url` 中并没有传递主机名（`hostname`）
- 随着虚拟化技术的发展，一台物理机上可以有多个虚拟机，共享同一个 `IP` 地址，`1.1` 中的请求消息和响应消息都支持 `Host`，请求消息中如果没有 `Host` 头域会报告一个错误（`400 Bad Request`）

4. 长连接：

- `http` 是基于 `TCP/IP` 协议的，创建一个 `TCP` 连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。
- `1.0` 中每次需要使用 `keep-alive` 参数来告知服务器端要建立一个长连接
- `1.1` 默认支持长连接，一定程度上弥补了 `HTTP1.0` 每次请求都要创建连接的缺点

5. 新增状态码：

- `1.1` 中新增了 24 个错误状态响应码，如 `409（Conflict）` 表示请求的资源与资源的当前状态发生冲突；`410（Gone）` 表示服务器上的某个资源被永久性的删除

6. 新增请求方式：

- `PUT`，`DELETE`，`OPTIONS` 等

**HTTP2.0 和 HTTP1.X 的区别**

1. **header 压缩**：header 头部带有大量的信息，而且每次使用报头压缩，降低开销，对于相同的 header 数据，不再通过每次请求和响应发送，差量更新 HTTP 头部，既避免了重复 header 的传输，又减小了需要传输的大小

2. **多路复用**：在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序

3. **二进制分帧**：消息由一个或多个帧组成。多个帧之间可以乱序发送

4. **服务端推送**：`HTTP2` 引入服务器推送，允许服务端推送资源给客户端,服务器会顺便把一些客户端需要的资源一起推送到客户端

---

## HTTP 和 HTTPS 的区别

1. HTTP 传输的数据都是未加密的，也就是明文的，HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。
2. HTTPS 协议需要 CA 证书。
3. 使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。

---

## HTTPS 协议的工作原理

1. 客户使用 HTTPS URL 访问服务器，则要求 web 服务器建立 SSL 链接，客户端向服务器发送的报文包括客户端所支持的 ssl 版本，支持的加密算法以及密钥的长度。
2. web 服务器接收到客户端的请求之后，也在报文中包含 SSL 版本以及加密组件，服务器的加密组件内容时从接收到的客户端加密组件内筛选出来的。
3. 同时，web 服务器会将网站的 CA 证书（证书中包含了公钥），返回给客户端。
4. 客户端通过 CA 证书来验证服务端的身份，公钥是否有效，比如颁发机构，过期时间，并随机生成对称加密的密钥 X 用公钥加密发给服务端。
5. 服务器拿到客户端发过来的加密内容用自己的私钥解密获取到密钥 X。
6. 双方都拿到了密钥 X，SSL 通道建立完成，通过密钥 X 加密信息来进行通信。

总结：HTTPS 协议使用了 **非对称加密（传输对称密钥） + 对称加密（后续数据传输）** 的方式，即利用了非对称加密安全性高的特点，又利用了对称加密速度快，效率高的好处。

## 在浏览器输入 URL 回车之后发生了什么？

1. **URL 解析**

- 地址解析：判断输入是一个合法的 URL 还是一个搜索关键字，并且根据输入进行自动完成、字符编码等操作。
- HSTS：检查 HSTS 列表(HTTP Strict Transport Security)，如果在列表中则强制使用 HTTPS。
- 其他操作：比如安全检查、访问限制。
- 检查缓存：如果浏览器有缓存，则直接返回缓存内容。
  
2. **DNS 查询**

- 浏览器缓存：浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。
- 操作系统缓存：操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。
- 路由器缓存：路由器也有自己的 DNS 缓存。
- ISP 的 DNS 缓存：ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。
- 根域名服务器查询：在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域。

![DNS 查询流程](img/dns.png)

3. **TCP 连接**

TCP/IP 分为四层，分别是应用层、传输层、网络层、链路层。在发送数据时，每层都会对数据进行包装，增加一些信息，比如传输层会添加 TCP 头，网络层会添加 IP 头，链路层会添加 MAC 头。

![TCP/IP 四层模型](img/TCP_IP.png)

4. **服务器处理请求**

- HTTPD：最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。它会监听得到的请求，然后开启一个子进程去处理这个请求。
- 处理请求：接受 TCP 报文，解析请求行、请求头、请求体，并根据请求行中的请求方法，决定如何处理请求。
- 重定向：如果请求的资源需要重定向，则返回 `301` 或 `302` 状态码。浏览器会根据状态码重新发送请求。
- URL 重写：如果请求的资源是真实存在的，则会把这个文件返回给浏览器。否则，服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。
  
5. **接受响应**

- 查看 header 信息，比如状态码、内容类型、内容长度等。根据状态码决定如何处理。
- 如果响应资源进行了压缩，需要解压。
- 对响应资源进行缓存。
- 根据响应资源的类型去解析响应内容。

6. **渲染页面**

- HTML 解析
- CSS 解析
- 渲染树
- 执行 JS 脚本

